package ch.tetrix.game.services

import ch.tetrix.assets.AudioAssets
import ch.tetrix.assets.get
import ch.tetrix.game.actors.Cube
import ch.tetrix.game.actors.Shape
import ch.tetrix.game.actors.shapeImplementations.RotorShape
import ch.tetrix.game.models.Directions
import ch.tetrix.game.models.GridPosition
import ch.tetrix.game.models.MoveResult
import ch.tetrix.game.models.ShapeType
import ch.tetrix.game.screens.GameScreen
import ch.tetrix.scoreboard.repositories.ScoreboardRepository
import ch.tetrix.shared.BehaviorSignal
import ch.tetrix.shared.ConfigManager
import com.badlogic.gdx.assets.AssetManager
import com.badlogic.gdx.audio.Sound
import com.badlogic.gdx.utils.Timer
import kotlin.math.max
import ktx.inject.Context
import ktx.log.logger
import ktx.scene2d.KTableWidget

/**
 * Service class responsible for managing the logic and behavior of a game.
 * Handles gameplay mechanics, such as shape movements, collisions, scoring, levels,
 * sound effects, and game state transitions like pausing, resuming, and ending the game.
 */
class GameService(private val context: Context) {
    companion object {
        private const val NUM_COLS: Int = 17
        private const val NUM_ROWS: Int = 36

        private const val INITIAL_FALL_INTERVAL_MS = 500f
        private const val MIN_FALL_INTERVAL_MS = 100f
        private const val FALL_INTERVAL_LEVE_DECREASE = 50f
        private const val SQUARES_PER_LEVEL = 5
        private const val FAST_FALL_FACTOR = 5
        private const val LOCK_DELAY_S = 0.5f
        private const val MAX_LOCK_DELAY_RESETS = 7

        private val log = logger<GameService>()
    }

    /**
     * Represents the number of columns in the game grid.
     * This value is derived from the constant `NUM_COLS` and is used as a read-only property.
     */
    val cols: Int
        get() = NUM_COLS

    /**
     * Represents the total number of rows in the game grid.
     * Used internally to manage and configure the game grid dimensions.
     */
    val rows: Int
        get() = NUM_ROWS

    private lateinit var gameScreen: GameScreen
    private var assets: AssetManager = context.inject<AssetManager>()
    private val config by lazy { ConfigManager.playerConfig }

    private lateinit var tetrominoRotateSound: Sound
    private lateinit var tetrominoMoveSound: Sound
    private lateinit var tetrominoLandedSound: Sound
    private lateinit var tetrominoHardDropSound: Sound
    private lateinit var tetrominoFallingAfterSquareClearSound: Sound
    private lateinit var squareClearSound: Sound
    private lateinit var rotorRotateSound: Sound
    private lateinit var levelUpSound: Sound
    private lateinit var gameOverSound: Sound

    private var activeShape: Shape? = null
    private var nextShape: Shape? = null
    private lateinit var rotor: RotorShape

    private val _shapes = arrayListOf<Shape>()

    /**
     * A map representing the current positions of all cubes in the game, where each key is a `GridPosition`
     * indicating the cube's position on the grid, and each value is the corresponding `Cube` instance.
     *
     * The map is dynamically generated by aggregating the cubes from all active shapes in the game field.
     * This allows for quick lookup of cubes based on their grid position, which is often used to determine
     * collisions, validate movements, or check for overlaps in the game logic.
     *
     * The cube positions are computed by flattening the list of cubes belonging to all shapes in `_shapes`
     * and associating each cube's `gridPos` with the cube itself.
     *
     * @return A map of `GridPosition` to `Cube`, representing the positions and state of all cubes in the game.
     */
    val cubePositions: Map<GridPosition, Cube>
        get() = _shapes.flatMap { it.cubes.toList() }.associateBy { it.gridPos }

    /**
     * Represents the highest score achieved in the game.
     *
     * This variable is a `BehaviorSignal` initialized to `0` and tracks updates
     * to the high score during the game. Its value is updated when a new game starts,
     * during score updates, or when the game ends, based on the current score value.
     * It ensures that the high score is always accessible throughout the game lifecycle.
     */
    val highScore = BehaviorSignal(0)

    /**
     * The current score of the game.
     *
     * This variable uses a `BehaviorSignal` to hold the score value, allowing the game to
     * reactively observe and update the score in real-time across different components.
     *
     * The score is reset to `0` when a new game starts or when the game is reset.
     * It is incremented whenever the player earns points during gameplay.
     * If the current score surpasses the high score, the high score is updated accordingly.
     */
    val score = BehaviorSignal(0)

    /**
     * Represents the current level of the game.
     *
     * The level is updated as the player progresses by clearing squares.
     * It also impacts gameplay mechanics like the fall speed of the shapes.
     *
     * Changes in the level are accompanied by sound effects and updates to the fall speed.
     */
    val level = BehaviorSignal(0)

    /**
     * Tracks the total number of squares cleared during the game.
     *
     * This value is updated when squares are destroyed during gameplay,
     * typically as a result of clearing lines or specific game mechanics
     * reducing the number of squares. It is used to calculate the player's
     * progress towards leveling up and is displayed in the game interface.
     */
    val squares = BehaviorSignal(0)

    /**
     * Represents the current active state of the game.
     * This signal emits `true` when the game is active, and `false` otherwise.
     *
     * The value is updated during significant game state transitions such as starting, pausing, resuming, or ending the game.
     * It is also checked to ensure valid operations, such as moving or rotating shapes, are performed only when the game is active.
     */
    val isGameActive = BehaviorSignal(false)

    /**
     * Represents the current paused state of the game.
     *
     * This property indicates whether the game is currently paused or active.
     * It is updated to `true` when the game is paused (e.g., via the `pauseGame` method)
     * and to `false` when the game is resumed (e.g., via the `resumeGame` method).
     *
     * It is also reset to `false` when a new game starts or the game ends.
     * Modifications to this property trigger appropriate changes in the game's active state,
     * affecting the game loop and rendering behavior.
     */
    val isGamePaused = BehaviorSignal(false)

    /**
     * Represents a signal that indicates whether the game is over.
     *
     * Emits a boolean value with `true` signifying that the game has ended
     * and `false` signifying that the game is ongoing. This signal is used
     * for managing game state, such as transitioning to a Game Over screen
     * or stopping gameplay-related activities when the game ends.
     *
     * The value is initialized to `false` when a new game is started and
     * changes to `true` when the game ends.
     */
    val isGameOver = BehaviorSignal(false)

    private var fallIntervalMs = INITIAL_FALL_INTERVAL_MS
    private var isFastFallActive = false
    private var gameTimer: Timer.Task? = null
    private var lockDelay: Timer.Task? = null
    private var lockDelayResets = 0

    init {
        setGamesound()
    }

    /**
     * Initiates a new game session by setting up the game screen, resetting the game state,
     * initializing the rotor, and configuring the game's starting values.
     *
     * @param gameScreen The game screen instance to attach to the new game session.
     */
    fun startNewGame(gameScreen: GameScreen) {
        log.info { "Starting new game" }
        reset()
        this.gameScreen = gameScreen
        val scoreboardRepo = context.inject<ScoreboardRepository>()
        highScore.dispatch(scoreboardRepo.getHighScore()?.score ?: 0)
        setRotor(RotorShape(this.gameScreen.gameStage.table, context, squareClearSound, tetrominoFallingAfterSquareClearSound))
        isGameActive.dispatch(true)
        isGameOver.dispatch(false)
        isGamePaused.dispatch(false)
        gameStep()
    }

    private fun setGamesound() {
        tetrominoRotateSound = assets[AudioAssets.TETROMINO_ROTATE]
        tetrominoMoveSound = assets[AudioAssets.TETROMINO_MOVE]
        tetrominoLandedSound = assets[AudioAssets.TETROMINO_LANDED]
        tetrominoHardDropSound = assets[AudioAssets.TETROMINO_HARD_DROP]
        tetrominoFallingAfterSquareClearSound = assets[AudioAssets.TETROMINO_FALLING_AFTER_SQUARE_CLEAR]
        squareClearSound = assets[AudioAssets.SQUARE_CLEAR]
        rotorRotateSound = assets[AudioAssets.ROTOR_ROTATE]
        levelUpSound = assets[AudioAssets.LEVEL_UP]
        gameOverSound = assets[AudioAssets.GAME_OVER]
    }

    /**
     * Resets all game values to initial state
     */
    private fun reset() {
        if(::gameScreen.isInitialized) {
            gameScreen.gameStage.dispose()
        }

        if(::rotor.isInitialized) {
            rotor.remove()
        }

        activeShape?.remove()

        isFastFallActive = false
        _shapes.clear()
        gameTimer?.cancel()
        gameTimer = null
        lockDelay?.cancel()
        lockDelay = null
        lockDelayResets = 0
        score.dispatch(0)
        level.dispatch(0)
        squares.dispatch(0)
        highScore.dispatch(0)
        isGameActive.dispatch(false)
        isGamePaused.dispatch(false)
        isGameOver.dispatch(false)
        updateFallSpeed()
    }

    /**
     * Pauses the current game session.
     *
     * This method checks whether the game is active and, if so, pauses it. The active game state
     * is updated to indicate the game is paused, and a corresponding log message is recorded.
     */
    fun pauseGame() {
        if (isGameActive.value) {
            log.info { "Game paused" }
            isGamePaused.dispatch(true)
            isGameActive.dispatch(false)
        }
    }

    /**
     * Resumes the currently paused game session.
     *
     * This method checks the current game state to ensure the game is not active and has not ended.
     * If the game is paused, it logs a resume event, updates the game state to active, and schedules
     * the next game step.
     */
    fun resumeGame() {
        if (!isGameActive.value && !isGameOver.value) {
            log.info { "Game resumed" }
            isGamePaused.dispatch(false)
            isGameActive.dispatch(true)
            scheduleNextStep()
        }
    }

    /**
     * Ends the current game session and handles the cleanup and state update processes.
     *
     * Invoking this method ensures that the game state is properly finalized, allowing for any further
     * transitions, such as navigating to a "Game Over" screen or initiating a new game.
     */
    fun endGame() {
        log.info { "Game ended. Final score: ${score.value}" }
        gameOverSound.play(config.audio.soundVolume)
        isGameActive.dispatch(false)
        isGameOver.dispatch(true)
        isGamePaused.dispatch(false)

        if (score.value > highScore.value) {
            log.info { "New high score: ${score.value}" }
            highScore.dispatch(score.value)
        }
    }

    /**
     * Checks if the given grid position is outside the defined bounds of the game grid.
     *
     * @param pos The position to check, defined by x and y coordinates.
     * @return True if the position is out of bounds, otherwise false.
     */
    fun isOutOfBounds(pos: GridPosition): Boolean {
        return pos.x !in 0 until NUM_COLS || pos.y !in 0 until NUM_ROWS
    }

    /**
     * Moves the currently active shape in the specified direction.
     *
     * This method updates the position of the active shape within the game grid
     * if the direction is valid and does not result in collisions or invalid movements.
     * If the movement is successful, any necessary game state updates, such as resetting
     * the lock delay, are performed.
     *
     * @param direction The direction in which to attempt moving the active shape, defined by the `Directions` enum.
     * @return A `MoveResult` indicating the result of the move. This can be `MoveResult.Success` if the movement
     *         is successful or `MoveResult.Collision` in case there is an obstruction, such as a collision with
     *         another shape or the game borders.
     */
    fun moveActiveShape(direction: Directions): MoveResult {
        if (!isGameActive.value || activeShape == null || activeShape?.fallDirection?.opposite() == direction) {
            return MoveResult.Success
        }

        val moveResult =  activeShape!!.move(direction)
        if (moveResult is MoveResult.Success) {
            handleLockDelayReset()
        }
        return moveResult
    }

    /**
     * Immediately drops the active shape to the lowest possible position in the game grid.
     *
     * This method ensures that the active shape is moved directly downwards
     * until it either collides with another shape or reaches the bottom of the game grid.
     *
     * Steps performed by the method:
     * - Checks whether the game is active, whether there is an active shape,
     *   and whether the lock delay timer is scheduled. If any of these conditions
     *   are not met, the method exits early.
     * - Cancels the current game timer.
     * - Moves the active shape repeatedly in its fall direction until a collision occurs.
     * - Plays a sound effect indicating a hard drop.
     * - Handles the collision using the collided state of the active shape.
     */
    fun snapActiveShape() {
        val lockDelay = this.lockDelay
        val activeShape = this.activeShape
        if (!isGameActive.value || activeShape == null || (lockDelay != null && lockDelay.isScheduled)) {
            return
        }

        gameTimer?.cancel()
        var result: MoveResult?

        do {
            result = moveActiveShape(activeShape.fallDirection)
        } while (result is MoveResult.Success)

        tetrominoHardDropSound.play(config.audio.soundVolume)
        handleCollision(result as MoveResult.Collision, activeShape)
    }

    /**
     * Rotates the currently active shape clockwise by 90 degrees within the game grid.
     *
     * This method checks if the game is active and whether an active shape is present
     * before attempting the rotation. If the rotation is successful:
     * - Plays the rotation sound effect at the configured audio volume.
     * - Resets the lock delay timer to ensure smoother gameplay transitions.
     *
     * If the rotation is not possible or the game is inactive, the method exits without performing any action.
     */
    fun rotateActiveShapeClockwise() {
        if (!isGameActive.value || activeShape == null) {
            return
        }

        val success = activeShape!!.rotateClockwise()
        if (success) {
            tetrominoRotateSound.play(config.audio.soundVolume)
            handleLockDelayReset()
        }
    }

    /**
     * Rotates the currently active shape in the game counterclockwise.
     *
     * This method performs the following steps:
     * 1. Verifies if the game is in an active state and if there is a shape currently active.
     * 2. Attempts to rotate the active shape counterclockwise by invoking its corresponding method.
     * 3. If the rotation is successful:
     *    - Plays the sound effect for a shape rotation.
     *    - Resets the lock delay to prevent the shape from locking immediately.
     *
     * If the game is not active or there is no active shape, it exits early without performing any operation.
     */
    fun rotateActiveShapeCounterClockwise() {
        if (!isGameActive.value || activeShape == null) {
            return
        }

        val success = activeShape!!.rotateCounterClockwise()
        if (success) {
            tetrominoRotateSound.play(config.audio.soundVolume)
            handleLockDelayReset()
        }
    }

    /**
     * Rotates the rotor in the game clockwise.
     *
     * This method performs the following operations:
     * 1. Verifies the game's active state; exits early if the game is not active.
     * 2. Plays the rotor rotation sound effect using the configured audio volume.
     * 3. Initiates the clockwise rotation of the rotor.
     */
    fun rotateRotorClockwise() {
        if (!isGameActive.value) {
            return
        }

        rotorRotateSound.play(config.audio.soundVolume)
        rotor.rotateClockwise()
    }

    /**
     * Rotates the rotor counterclockwise by 90 degrees, if the game is active.
     *
     * This method performs the following steps:
     * 1. Verifies if the game is in an active state. If the game is not active, the method exits early.
     * 2. Plays the rotor rotation sound effect at the configured audio volume.
     * 3. Invokes the rotor's `rotateCounterClockwise` method to perform the rotation.
     */
    fun rotateRotorCounterClockwise() {
        if (!isGameActive.value) {
            return
        }

        rotorRotateSound.play(config.audio.soundVolume)
        rotor.rotateCounterClockwise()
    }

    private fun gameStep() {
        if (!isGameActive.value) {
            return
        }

        if (activeShape == null && nextShape == null) {
            setActiveShape(ShapeType.randomType())
            setNextShape(ShapeType.randomType())
        } else if (activeShape == null && nextShape != null) {
            setActiveShape(nextShape!!.shapeType)

            nextShape?.remove()
            nextShape = null
            setNextShape(ShapeType.randomType())
        }

        val moveResult = activeShape?.move(activeShape!!.fallDirection)

        if (moveResult !is MoveResult.Collision) {
            // valid step, piece is not colliding (e.g. fell into a gap)
            log.debug { "Shape moved down, reset lock delay." }
            lockDelay?.cancel()
            lockDelayResets = 0
            scheduleNextStep()
            return
        }

        handleCollision(moveResult, activeShape!!)
    }

    private fun handleCollision(moveResult: MoveResult.Collision, activeShape: Shape) {
        val collidedWith = moveResult.collisionObject

        scheduleNextStep()

        if (collidedWith == null) {
            handleGameBorderCollision(activeShape)
            return
        }

        // If lock delay is already running, do nothing.
        // Player moves will reset it.
        if (lockDelay?.isScheduled == true) {
            return
        }

        log.info { "Collision with ${collidedWith.javaClass.simpleName}, lock delay started." }
        lockDelayResets = 0 // Reset for the start of a new lock sequence
        startLockDelayTimer()
    }

    private fun handleGameBorderCollision(activeShape: Shape) {
        if (activeShape.fallDirection == Directions.DOWN) {
            // return to top
            activeShape.fallDirection = Directions.UP
            if (isFastFallActive) {
                disableFastFall()
            }
        }
        else if (activeShape.fallDirection == Directions.UP) {
            endGame()
        }
    }

    private fun setActiveShape(shapeType: ShapeType) {
        activeShape = shapeType.create(gameScreen.gameStage.table, context)
        addShapeToGameStage(activeShape!!)
        lockDelay?.cancel()
        log.debug { "reset lock delay." }
        lockDelayResets = 0
    }

    private fun setNextShape(shapeType: ShapeType) {
        val table = gameScreen.stage.root.findActor<KTableWidget>("nextShapeTable")
        val shape = shapeType.create(table, context, position = GridPosition(2, 1))
        nextShape = addShapeToNextShapeComponent(shape)
    }

    private fun setRotor(shape: RotorShape) {
        rotor = addShapeToGameStage(shape)
    }

    private fun <T: Shape> addShapeToGameStage(shape: T): T{
        val canPlaceShape = shape.cubes.map { it.gridPos }.all { !cubePositions.containsKey(it) }

        if (!canPlaceShape) {
            log.info { "Unable to place shape ${shape.javaClass.simpleName}, it collides with existing cubes." }
            endGame()
        }

        _shapes.add(shape)

        gameScreen.gameStage.addActor(shape)
        return shape
    }

    private fun <T: Shape> addShapeToNextShapeComponent(shape: T): T{
        gameScreen.stage.addActor(shape)
        return shape
    }

    /** used to move cubes from one shape to another (usually the rotor) */
    private fun attachActiveShapeToRotor() {
        lockDelay?.cancel()

        if (activeShape?.hasChildren() == false || activeShape!!.canMove()) {
            return
        }

        activeShape?.transferCubesTo(rotor)
        tetrominoLandedSound.play(config.audio.soundVolume)
        activeShape?.remove()
        _shapes.remove(activeShape)
        activeShape = null

        gameTimer?.cancel()

        rotor.removeSquaresAsync { result ->
            log.info { "Shape attached to rotor. Cubes: ${result.cubesDestroyed}, Squares: ${result.squaresDestroyed}" }
            updateScore(result.cubesDestroyed * result.squaresDestroyed)
            squares.dispatch(squares.value + result.squaresDestroyed)
            updateLevel()

            log.info { "Next step" }
            scheduleNextStep()
        }
    }

    private fun startLockDelayTimer() {
        lockDelay?.cancel()
        lockDelay = object : Timer.Task() {
            override fun run() {
                log.info { "Lock delay over, shape connected." }
                attachActiveShapeToRotor()
            }
        }
        Timer.schedule(lockDelay, LOCK_DELAY_S)
    }

    private fun handleLockDelayReset() {
        if (lockDelay?.isScheduled != true) {
            return // Not in a lock delay state
        }

        if (lockDelayResets < MAX_LOCK_DELAY_RESETS) {
            lockDelayResets++
            log.info { "Lock delay reset. Count: $lockDelayResets/$MAX_LOCK_DELAY_RESETS" }
            lockDelay?.cancel()
            startLockDelayTimer() // Restart the timer
        } else {
            log.info { "Max lock delay resets reached. Forcing shape lock." }
            lockDelay?.run()
        }
    }

    private fun updateScore(addedScore: Int) {
        score.dispatch(score.value + addedScore)
        if (highScore.value < score.value) {
            highScore.dispatch(score.value)
        }
    }

    private fun updateLevel() {
        val totalSquares = squares.value
        val currentLevel = level.value
        val actualLevel = Math.floorDiv(totalSquares, SQUARES_PER_LEVEL)

        if (currentLevel != actualLevel) {
            levelUpSound.play(config.audio.soundVolume)
            level.dispatch(actualLevel)
            log.info { "Level up! level: $currentLevel -> $actualLevel squares: $totalSquares" }
            updateFallSpeed()
        }
    }

    private fun updateFallSpeed() {
        val currentLevel = level.value
        fallIntervalMs = max(MIN_FALL_INTERVAL_MS, INITIAL_FALL_INTERVAL_MS - currentLevel * FALL_INTERVAL_LEVE_DECREASE)
        log.info { "Fall speed updated to ${fallIntervalMs}ms for level $currentLevel" }

        scheduleNextStep()
    }

    private fun scheduleNextStep() {
        gameTimer?.cancel()

        if (!isGameActive.value) {
            return
        }

        gameTimer = object : Timer.Task() {
            override fun run() {
                gameStep()
            }
        }

        val interval =
            if (isFastFallActive) {
                fallIntervalMs / FAST_FALL_FACTOR / 1000f
            }
            else {
                fallIntervalMs / 1000f
            }

        Timer.schedule(gameTimer, max(MIN_FALL_INTERVAL_MS / 1000f, interval))
    }

    /**
     * Enables fast fall mode for the currently active shape in the specified direction.
     *
     * This method checks if the game is active, there is an active shape, fast fall is not
     * yet active, and the specified direction does not oppose the current fall direction
     * of the active shape. If all conditions are met, fast fall mode is enabled, and the game
     * step process is speeded up.
     *
     * @param direction The direction in which to enable fast fall, defined by the `Directions` enum.
     * @return True if fast fall mode was successfully enabled, otherwise false if any condition to enable it failed.
     */
    fun enableFastFall(direction: Directions): Boolean {
        if (
            !isGameActive.value
            || activeShape == null
            || isFastFallActive
            || activeShape!!.fallDirection.opposite() == direction
        ) {
            return false
        }

        isFastFallActive = true
        log.debug { "Fast fall enabled " }
        scheduleNextStep()
        gameStep()
        return true
    }

    /**
     * Disables the fast fall mode in the game if it is currently active.
     *
     * This method checks whether fast fall mode is active. If it is,
     * it disables the fast fall mode by resetting the relevant state variable,
     * logs this change, and schedules the next game step with the appropriate speed.
     *
     * @return `true` if fast fall mode was active and successfully disabled,
     *         otherwise `false` if the fast fall mode was not active.
     */
    fun disableFastFall(): Boolean {
        if (!isFastFallActive) {
            return false
        }

        isFastFallActive = false
        log.debug { "Fast fall disabled" }
        scheduleNextStep()
        return true
    }
}
